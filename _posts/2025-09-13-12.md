---
title: Binary Exploitation 101 - Shellcode
date: 2025-09-13
categories: [Guide, Binary Exploitation 101]
tags: [linux, pwn, ctf]
---

> This blog series is still a work in progress. The content may change without notice.
{: .prompt-warning }

In this chapter, we'll learn how system calls work and shellcode. The materials for this chapter can be found in the [chapter_04](https://github.com/r1ru/binary-exploitation-101/tree/main/chapter_04) folder.

## Introduction
If we open `chal.c`{: .filepath}, we'll see the `win` function has been removed. Everything else is unchanged. As in the previous chapter, we can still take control via buffer overflow, but the real question is how to spawn a shell. To answer that, we need to analyze what the `win` function did and understand how system calls work.

![](/assets/img/posts/2025-09-13-12/0.jpg){: w="500" h="500" }

## How System Calls Work
A system call is the mechanism that lets user-space programs use services provided by the OS kernel. The `win` function spawned a shell by invoking the [execve](https://man7.org/linux/man-pages/man2/execve.2.html) system call. Now let's study how system calls work using `win.c`{: .filepath} as an example. The program is exactly the same as the `win` function from the previous chapter:
```c
int main(void) {
    char *argv[] = {"/bin/sh", NULL};
    execve(argv[0], argv, NULL);
}
```
{: file="win.c" }
Start pwndbg with the following command:
```bash
pwndbg -q --ex 'b main' --ex 'r' ./win
```
Use `disass` to see `main` in assembly, set a breakpoint at the `execve` call with `b *0x401897`, and continue with `c`:

![](/assets/img/posts/2025-09-13-12/1.jpg){: w="500" h="500" }

`execve` takes three arguments. As we learned earlier, under the System V AMD64 ABI the first three arguments are passed in rdi, rsi, and rdx. You can confirm this with `i r rdi rsi rdx`, `x/s $rdi`, and `x/2xw $rsi`:

![](/assets/img/posts/2025-09-13-12/2.jpg){: w="500" h="500" }

Next, step into the `execve` function with `si`, then use `disass` to see the assembly:

![](/assets/img/posts/2025-09-13-12/3.jpg){: w="500" h="500" }

Here the code places 0x3b in eax and executes the syscall instruction. The syscall instruction transfers control to the kernel's system call handler. Under the System V ABI, the system call number is placed in rax and the syscall arguments are placed in rdi, rsi, rdx, **r10**, r8, and r9 before executing syscall. See the [spec](https://gitlab.com/x86-psABIs/x86-64-ABI) section "A.2.1 Calling Conventions" for details.

One important difference from ordinary function calls is that the fourth argument (0-indexed) is passed in r10 rather than rcx. This is because the syscall instruction uses rcx to store the return address. For more details, see the [Intel SDM](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html):

![](/assets/img/posts/2025-09-13-12/4.jpg){: w="700" h="700" }

## Shellcode
Now that we have learned how to invoke system calls in assembly, let's actually write shellcode that executes a shell:
```nasm
.intel_syntax noprefix
        .global _start
    _start:
        xor rdx, rdx
        push rdx
        mov rax, 0x68732f6e69622f
        push rax 
        mov rdi, rsp
        push rdx
        push rdi 
        mov rsi, rsp 
        mov rax, 0x3b
        syscall
```
{: file="shellcode.s" }
Here, `0x68732f6e69622f` is the hexadecimal representation of "/bin/sh". We set rdx to `NULL`, push "/bin/sh" onto the stack, and store its address in rdi. Then we push rdi and `NULL` onto the stack to construct `argv`, and store its address in rsi. Finally, we set rax to the execve system call number (0x3b) and execute the syscall instruction. You can step through this in GDB to see the details. Running this program confirms that the shell launches as expected.

## Exercise
Based on what you have learned so far, write an exploit that launches a shell using buffer overflow. Before you start, **make sure to execute the following command** (if you are using a Docker container, run it on the host):
```bash
sudo sysctl -w kernel.randomize_va_space=0
```
This command disables ASLR (Address Space Layout Randomization), which will be explained in a later chapter. You can use the [template](https://github.com/r1ru/binary-exploitation-101/blob/main/exploit_template.py), and the following hints may help. If successful, you should be able to launch a shell like this:

![](/assets/img/posts/2025-09-13-12/5.jpg){: w="500" h="500" }

If you have any questions, feel free to leave a comment below. You can see my solution [here](https://github.com/r1ru/binary-exploitation-101/blob/main/chapter_04/solution.py).

## Hints
- The size of `buf` is 0x20 bytes, which is too small to hold the shellcode. It is better to place the shellcode after the return address.
- Even with ASLR disabled, the stack address may differ depending on whether you run the program in a debugger, normally, or via a Python script.